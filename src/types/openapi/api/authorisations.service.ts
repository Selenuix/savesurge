/**
 * Yapily API
 *
 * Contact: support@yapily.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { AccountAuthorisationRequest } from '../model/accountAuthorisationRequest';
// @ts-ignore
import { ApiResponseError } from '../model/apiResponseError';
// @ts-ignore
import { ApiResponseOfAccountAuthorisationResponse } from '../model/apiResponseOfAccountAuthorisationResponse';
// @ts-ignore
import { ApiResponseOfEmbeddedAccountAuthorisationResponse } from '../model/apiResponseOfEmbeddedAccountAuthorisationResponse';
// @ts-ignore
import { ApiResponseOfPaymentAuthorisationRequestResponse } from '../model/apiResponseOfPaymentAuthorisationRequestResponse';
// @ts-ignore
import { ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse } from '../model/apiResponseOfPaymentEmbeddedAuthorisationRequestResponse';
// @ts-ignore
import { ApiResponseOfPreAuthorisationResponse } from '../model/apiResponseOfPreAuthorisationResponse';
// @ts-ignore
import { BulkPaymentAuthorisationRequest } from '../model/bulkPaymentAuthorisationRequest';
// @ts-ignore
import { BulkPaymentEmbeddedAuthorisationRequest } from '../model/bulkPaymentEmbeddedAuthorisationRequest';
// @ts-ignore
import { EmbeddedAccountAuthorisationRequest } from '../model/embeddedAccountAuthorisationRequest';
// @ts-ignore
import { PaymentAuthorisationRequest } from '../model/paymentAuthorisationRequest';
// @ts-ignore
import { PaymentEmbeddedAuthorisationRequest } from '../model/paymentEmbeddedAuthorisationRequest';
// @ts-ignore
import { PaymentPreAuthorisationRequest } from '../model/paymentPreAuthorisationRequest';
// @ts-ignore
import { PreAuthorisationRequest } from '../model/preAuthorisationRequest';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import {
    AuthorisationsServiceInterface
} from './authorisations.serviceInterface';



@Injectable({
  providedIn: 'root'
})
export class AuthorisationsService implements AuthorisationsServiceInterface {

    protected basePath = 'https://api.yapily.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;
            if (firstBasePath != undefined) {
                basePath = firstBasePath;
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Create Bulk Payment Authorisation
     * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. &lt;br&gt;&lt;br&gt;See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_BULK_PAYMENT&#x60;
     * @param bulkPaymentAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentAuthorisationRequestResponse>;
    public createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentAuthorisationRequestResponse>>;
    public createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentAuthorisationRequestResponse>>;
    public createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (bulkPaymentAuthorisationRequest === null || bulkPaymentAuthorisationRequest === undefined) {
            throw new Error('Required parameter bulkPaymentAuthorisationRequest was null or undefined when calling createBulkPaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/bulk-payment-auth-requests`;
        return this.httpClient.request<ApiResponseOfPaymentAuthorisationRequestResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: bulkPaymentAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Embedded Bulk Payment Authorisation
     * Used to initiate the embedded authorisation process for an &#x60;Institution&#x60; that contains the &#x60;INITIATE_EMBEDDED_BULK_PAYMENT&#x60; feature in order to obtain the the user\&#39;s authorisation for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. &lt;br&gt;&lt;br&gt; See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_EMBEDDED_BULK_PAYMENT&#x60;
     * @param bulkPaymentEmbeddedAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>;
    public createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (bulkPaymentEmbeddedAuthorisationRequest === null || bulkPaymentEmbeddedAuthorisationRequest === undefined) {
            throw new Error('Required parameter bulkPaymentEmbeddedAuthorisationRequest was null or undefined when calling createEmbeddedBulkPaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/embedded-bulk-payment-auth-requests`;
        return this.httpClient.request<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: bulkPaymentEmbeddedAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Embedded Payment Authorisation
     * Used to initiate the embedded authorisation process for an &#x60;Institution&#x60; that contains the &#x60;INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT&#x60; feature in order to obtain the the user\&#39;s authorisation for a payment.&lt;br&gt;&lt;br&gt; See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT&#x60;
     * @param paymentEmbeddedAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>;
    public createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (paymentEmbeddedAuthorisationRequest === null || paymentEmbeddedAuthorisationRequest === undefined) {
            throw new Error('Required parameter paymentEmbeddedAuthorisationRequest was null or undefined when calling createEmbeddedPaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/embedded-payment-auth-requests`;
        return this.httpClient.request<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paymentEmbeddedAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Payment Authorisation
     * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a payment. This endpoint is used to initiate all the different payment listed below. Based on the type of payment you wish to make, you may be required to provide specific properties in [PaymentRequest](https://docs.yapily.com/api/reference/#operation/createPaymentAuthorisation!path&#x3D;paymentRequest&amp;t&#x3D;request). First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/reference/#operation/getInstitution). &lt;br&gt;&lt;br&gt;See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Features:&lt;ul&gt;&lt;li&gt;&#x60;INITIATE_DOMESTIC_PERIODIC_PAYMENT&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_DOMESTIC_SCHEDULED_PAYMENT&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_DOMESTIC_SINGLE_INSTANT_PAYMENT&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_DOMESTIC_SINGLE_PAYMENT&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_INTERNATIONAL_PERIODIC_PAYMENT&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_INTERNATIONAL_SCHEDULED_PAYMENT&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_INTERNATIONAL_SINGLE_PAYMENT&#x60;&lt;/li&gt;&lt;/ul&gt;
     * @param paymentAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentAuthorisationRequestResponse>;
    public createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentAuthorisationRequestResponse>>;
    public createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentAuthorisationRequestResponse>>;
    public createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (paymentAuthorisationRequest === null || paymentAuthorisationRequest === undefined) {
            throw new Error('Required parameter paymentAuthorisationRequest was null or undefined when calling createPaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/payment-auth-requests`;
        return this.httpClient.request<ApiResponseOfPaymentAuthorisationRequestResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paymentAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Payment Pre-authorisation
     * Used to initiate the pre-authorisation process for payments for CBI Globe institutions that contain the &#x60;INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS&#x60; feature to authenticate the user. &lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS&#x60;
     * @param paymentPreAuthorisationRequest 
     * @param raw __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPreAuthorisationResponse>;
    public createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPreAuthorisationResponse>>;
    public createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPreAuthorisationResponse>>;
    public createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (paymentPreAuthorisationRequest === null || paymentPreAuthorisationRequest === undefined) {
            throw new Error('Required parameter paymentPreAuthorisationRequest was null or undefined when calling createPaymentPreAuthorisationRequest.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (raw !== undefined && raw !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>raw, 'raw');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/payment-pre-auth-requests`;
        return this.httpClient.request<ApiResponseOfPreAuthorisationResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paymentPreAuthorisationRequest,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Pre-authorisation
     * Used to initiate the pre-authorisation process for any &#x60;Institution&#x60; that contains the &#x60;INITIATE_PRE_AUTHORISATION&#x60; feature to authenticate the user. &lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_PRE_AUTHORISATION&#x60;
     * @param preAuthorisationRequest 
     * @param raw __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPreAuthorisationResponse>;
    public createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPreAuthorisationResponse>>;
    public createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPreAuthorisationResponse>>;
    public createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (preAuthorisationRequest === null || preAuthorisationRequest === undefined) {
            throw new Error('Required parameter preAuthorisationRequest was null or undefined when calling createPreAuthorisationRequest.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (raw !== undefined && raw !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>raw, 'raw');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/pre-auth-requests`;
        return this.httpClient.request<ApiResponseOfPreAuthorisationResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: preAuthorisationRequest,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Account Authorisation
     * Used to initiate the authorisation process and direct users to the login screen of their financial institution in order to give consent to access account data.&lt;br&gt;&lt;br&gt;See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_ACCOUNT_REQUEST&#x60;
     * @param accountAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfAccountAuthorisationResponse>;
    public initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfAccountAuthorisationResponse>>;
    public initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfAccountAuthorisationResponse>>;
    public initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountAuthorisationRequest === null || accountAuthorisationRequest === undefined) {
            throw new Error('Required parameter accountAuthorisationRequest was null or undefined when calling initiateAccountRequest.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/account-auth-requests`;
        return this.httpClient.request<ApiResponseOfAccountAuthorisationResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: accountAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Embedded Account Authorisation
     * Used to initiate the embedded authorisation process for an &#x60;Institution&#x60; that contains the &#x60;INITIATE_EMBEDDED_ACCOUNT_REQUEST&#x60; feature in order to obtain the the user\&#39;s authorisation to access their account information. &lt;br&gt;&lt;br&gt;See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_EMBEDDED_ACCOUNT_REQUEST&#x60;
     * @param embeddedAccountAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfEmbeddedAccountAuthorisationResponse>;
    public initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfEmbeddedAccountAuthorisationResponse>>;
    public initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfEmbeddedAccountAuthorisationResponse>>;
    public initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (embeddedAccountAuthorisationRequest === null || embeddedAccountAuthorisationRequest === undefined) {
            throw new Error('Required parameter embeddedAccountAuthorisationRequest was null or undefined when calling initiateEmbeddedAccountRequest.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/embedded-account-auth-requests`;
        return this.httpClient.request<ApiResponseOfEmbeddedAccountAuthorisationResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: embeddedAccountAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Re-authorise Account Consent
     * Used to prompt the account holder for continued access to their financial data. This endpoint should be used when a &#x60;Consent&#x60; that was previously &#x60;AUTHORIZED&#x60; can no longer be used to retrieve data.&lt;br&gt;&lt;br&gt;See [Re-Authorisation](https://docs.yapily.com/pages/key-concepts/account-data/account-consents/#re-authorisation) for more information.
     * @param consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfAccountAuthorisationResponse>;
    public reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfAccountAuthorisationResponse>>;
    public reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfAccountAuthorisationResponse>>;
    public reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (consent === null || consent === undefined) {
            throw new Error('Required parameter consent was null or undefined when calling reAuthoriseAccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (consent !== undefined && consent !== null) {
            localVarHeaders = localVarHeaders.set('consent', String(consent));
        }
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/account-auth-requests`;
        return this.httpClient.request<ApiResponseOfAccountAuthorisationResponse>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Embedded Account Authorisation
     * Used to pass the SCA Code received from the &#x60;Institution&#x60; (and the SCA method selected by the user where multiple SCA methods are supported by the &#x60;Institution&#x60;) in order to complete the embedded authorisation to access the user\&#39;s financial data. &lt;br&gt;&lt;br&gt;See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_EMBEDDED_ACCOUNT_REQUEST&#x60;
     * @param consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param embeddedAccountAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfEmbeddedAccountAuthorisationResponse>;
    public updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfEmbeddedAccountAuthorisationResponse>>;
    public updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfEmbeddedAccountAuthorisationResponse>>;
    public updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (consentId === null || consentId === undefined) {
            throw new Error('Required parameter consentId was null or undefined when calling updateEmbeddedAccountRequest.');
        }
        if (embeddedAccountAuthorisationRequest === null || embeddedAccountAuthorisationRequest === undefined) {
            throw new Error('Required parameter embeddedAccountAuthorisationRequest was null or undefined when calling updateEmbeddedAccountRequest.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/embedded-account-auth-requests/${this.configuration.encodeParam({name: "consentId", value: consentId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ApiResponseOfEmbeddedAccountAuthorisationResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: embeddedAccountAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Embedded Bulk Payment Authorisation
     * Used to pass the SCA Code received from the &#x60;Institution&#x60; (and the SCA method selected by the user where multiple SCA methods are supported by the &#x60;Institution&#x60;) in order to complete the embedded authorisation to initiate a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. &lt;br&gt;&lt;br&gt;See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_EMBEDDED_BULK_PAYMENT&#x60;
     * @param consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param bulkPaymentEmbeddedAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>;
    public updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (consentId === null || consentId === undefined) {
            throw new Error('Required parameter consentId was null or undefined when calling updateEmbeddedBulkPaymentAuthorisation.');
        }
        if (bulkPaymentEmbeddedAuthorisationRequest === null || bulkPaymentEmbeddedAuthorisationRequest === undefined) {
            throw new Error('Required parameter bulkPaymentEmbeddedAuthorisationRequest was null or undefined when calling updateEmbeddedBulkPaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/embedded-bulk-payment-auth-requests/${this.configuration.encodeParam({name: "consentId", value: consentId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: bulkPaymentEmbeddedAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Embedded Payment Authorisation
     * Used to pass the SCA Code received from the &#x60;Institution&#x60; (and the SCA method selected by the user where multiple SCA methods are supported by the &#x60;Institution&#x60;) in order to complete the embedded authorisation to initiate a payment. &lt;br&gt;&lt;br&gt; See [Embedded Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/embedded/) for more information about this flow.&lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT&#x60;
     * @param consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param paymentEmbeddedAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>;
    public updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>>;
    public updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (consentId === null || consentId === undefined) {
            throw new Error('Required parameter consentId was null or undefined when calling updateEmbeddedPaymentAuthorisation.');
        }
        if (paymentEmbeddedAuthorisationRequest === null || paymentEmbeddedAuthorisationRequest === undefined) {
            throw new Error('Required parameter paymentEmbeddedAuthorisationRequest was null or undefined when calling updateEmbeddedPaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/embedded-payment-auth-requests/${this.configuration.encodeParam({name: "consentId", value: consentId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paymentEmbeddedAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Payment Pre-authorisation
     * Used to continue the authorisation process and for any &#x60;Institution&#x60; that contains the &#x60;INITIATE_PRE_AUTHORISATION&#x60; feature and direct user to the login screen of their financial institution in order to give consent to initiate a payment. &lt;br&gt;&lt;br&gt;See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow. &lt;br&gt;&lt;br&gt;Feature: &#x60;INITIATE_PRE_AUTHORISATION&#x60;
     * @param consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param paymentAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfPaymentAuthorisationRequestResponse>;
    public updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfPaymentAuthorisationRequestResponse>>;
    public updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfPaymentAuthorisationRequestResponse>>;
    public updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (consent === null || consent === undefined) {
            throw new Error('Required parameter consent was null or undefined when calling updatePaymentAuthorisation.');
        }
        if (paymentAuthorisationRequest === null || paymentAuthorisationRequest === undefined) {
            throw new Error('Required parameter paymentAuthorisationRequest was null or undefined when calling updatePaymentAuthorisation.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (consent !== undefined && consent !== null) {
            localVarHeaders = localVarHeaders.set('consent', String(consent));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/payment-auth-requests`;
        return this.httpClient.request<ApiResponseOfPaymentAuthorisationRequestResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paymentAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Account Pre-authorisation
     * Used to continue the authorisation process and for any &#x60;Institution&#x60; that contains the &#x60;INITIATE_PRE_AUTHORISATION&#x60; feature and direct user to the login screen of their financial institution in order to give consent to access account data. &lt;br&gt;&lt;br&gt;See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow. &lt;br&gt;&lt;br&gt;Features: &lt;ul&gt;&lt;li&gt;&#x60;INITIATE_ACCOUNT_REQUEST&#x60;&lt;/li&gt;&lt;li&gt;&#x60;INITIATE_PRE_AUTHORISATION&#x60;&lt;/li&gt;&lt;/ul&gt;
     * @param consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param accountAuthorisationRequest 
     * @param psuId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuCorporateId __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param psuIpAddress __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param subApplication The sub-application ID to which event type is being subscribed to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponseOfAccountAuthorisationResponse>;
    public updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponseOfAccountAuthorisationResponse>>;
    public updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponseOfAccountAuthorisationResponse>>;
    public updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, subApplication?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json;charset=UTF-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (consent === null || consent === undefined) {
            throw new Error('Required parameter consent was null or undefined when calling updatePreAuthoriseAccountConsent.');
        }
        if (accountAuthorisationRequest === null || accountAuthorisationRequest === undefined) {
            throw new Error('Required parameter accountAuthorisationRequest was null or undefined when calling updatePreAuthoriseAccountConsent.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (consent !== undefined && consent !== null) {
            localVarHeaders = localVarHeaders.set('consent', String(consent));
        }
        if (psuId !== undefined && psuId !== null) {
            localVarHeaders = localVarHeaders.set('psu-id', String(psuId));
        }
        if (psuCorporateId !== undefined && psuCorporateId !== null) {
            localVarHeaders = localVarHeaders.set('psu-corporate-id', String(psuCorporateId));
        }
        if (psuIpAddress !== undefined && psuIpAddress !== null) {
            localVarHeaders = localVarHeaders.set('psu-ip-address', String(psuIpAddress));
        }
        if (subApplication !== undefined && subApplication !== null) {
            localVarHeaders = localVarHeaders.set('sub-application', String(subApplication));
        }

        let localVarCredential: string | undefined;
        // authentication (basicAuth) required
        localVarCredential = this.configuration.lookupCredential('basicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/account-auth-requests`;
        return this.httpClient.request<ApiResponseOfAccountAuthorisationResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: accountAuthorisationRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
